convert_utf32_to_utf8 :: (ch: u32) -> Utf8_Char {
    UNI_MAX_LEGAL_UTF32 :: 0x0010FFFF;
    UNI_REPLACEMENT_CHAR :: 0x0000FFFD;

    count := 0;
    if ch < 0x80                        count = 1;
    else if ch < 0x800                  count = 2;
    else if ch < 0x10000                count = 3;
    else if ch <= UNI_MAX_LEGAL_UTF32   count = 4;
    else {
        count = 3;
        ch = UNI_REPLACEMENT_CHAR;
    }

    byteMask :: 0xBF;
    byteMark :: 0x80;

    bytes: [4] u8 = ---;

    if count == {
        case 4; bytes[3] = xx (ch | byteMark) & byteMask; ch = ch >> 6; #through;
        case 3; bytes[2] = xx (ch | byteMark) & byteMask; ch = ch >> 6; #through;
        case 2; bytes[1] = xx (ch | byteMark) & byteMask; ch = ch >> 6; #through;
        case 1; bytes[0] = xx (ch | firstByteMark[count]);
    }

    result: Utf8_Char = ---;
    result.bytes = bytes;
    result.count = xx count;
    return result;
}

to_string :: (utf8_char: *Utf8_Char) -> string {
    str: string = ---;
    str.data  = *utf8_char.bytes[0];
    str.count = utf8_char.count;
    return str;
}

Utf8_Char :: struct {
    bytes: [4] u8;
    count: s32;
}

opening_brackets :: u8.[#char "{", #char "(", #char "[", #char "<"];
closing_brackets :: u8.[#char "}", #char ")", #char "]", #char ">"];

is_bracket :: (c: u8) -> bracket: u8, matching_bracket: u8, is_opening_bracket: bool {
    for opening_brackets  if c == it  return c, closing_brackets[it_index], true;
    for closing_brackets  if c == it  return c, opening_brackets[it_index], false;
    return 0, 0, false;
}

is_closing_bracket :: (utf8: Utf8_Char) -> bool {
    if utf8.count != 1  return false;
    return is_closing_bracket(utf8.bytes[0]);
}

is_closing_bracket :: (c: u8) -> bool {
    #insert -> string {
        builder : String_Builder;
        append(*builder, "return ");
        for * closing_brackets {
            if it_index  append(*builder, " ||");
            print_to_builder(*builder, " c == #char \"%\"", strings.char_as_string(it));
        }
        append(*builder, ";");
        return builder_to_string(*builder);
    }
}


advance_by_chars :: (s: string, num_chars: s64) -> string #must, remainder: s64 {
    result := s;
    col := 0;
    while result && col < num_chars {
        byte := result[0];
        if byte != #char "\t" {
            advance(*result, 1 + trailingBytesForUTF8[byte]);
            col += 1;
        } else {
            advance(*result, 1);
            col += TAB_SIZE - col % TAB_SIZE;
        }
    }
    return result, col - num_chars;
}

take_first_n_chars :: (s: string, num_chars: s64) -> string #must {
    result := s;
    result.count -= advance_by_chars(result, num_chars).count;
    return result;
}

num_chars_in_string :: (s: string) -> s32 {
    num_chars: s32 = 0;

    while s {
        byte := s[0];
        if byte != #char "\t" {
            advance(*s, 1 + trailingBytesForUTF8[byte]);
            num_chars += 1;
        } else {
            advance(*s, 1);
            num_chars += TAB_SIZE - num_chars % TAB_SIZE;
        }
    }

    return num_chars;
}

next_char_offset :: inline (bytes: [] u8, offset: s32) -> s32 {
    assert(offset <= bytes.count-1);
    return offset + 1 + trailingBytesForUTF8[bytes[offset]];
}

prev_char_offset :: (bytes: [] u8, offset: s32) -> s32, byte: u8 {
    new_offset := offset - 1;
    byte := bytes[new_offset];
    while (byte & 0b1100_0000) == 0b1000_0000 {
        new_offset -= 1;
        byte = bytes[new_offset];
    }
    return new_offset, byte;
}

unicode_prev_character :: (s: *u8) -> new_s: *u8, char: u32 {  // NOTE: assuming the memory is valid utf-8, no checks are done!
    t := s - 1;
    while (<<t & 0b1100_0000) == 0b1000_0000 t -= 1;  // rewind to the first byte of a utf-8 sequence (all non-first bytes start with 10)

    char, _, result := character_utf8_to_utf32(t, s - t);
    return t, char;
}
